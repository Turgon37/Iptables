#!/bin/bash
#title         :iptables
#description   :Configure rules for iptables firewall
#author        :P.GINDRAUD
#author_contact:pgindraud@gmail.com
#created_on    :2014-05-30
#usage         :./iptables <CMD>
#usage_info    :use command 'help'
#options       :debug
#notes         :
# During the development process, please take a real care to report all errors,
# and don't worry about using debug option to control the good running of the
# script
#versions_notes:
# version 1.0
#    +first release
# version 2.0 : 2014-09-23
#    +re parsing of all rules
#    -remove return_state variables
#    +fix iptables error
# version 2.1 : 2014-09-24
#    +add missing _do_restart function
#    +correct functions syntax
#    +fix bug of test function
#    +add a verbose warning message
# version 2.2 : 2014-10-26
#    +add a new configuration file /etc/default/iptables
#    +set routing rules by a loop for configuration file
# version 3.0 : 2015-03-09
#    +refunding main loop and core processing, full dynamic loading
#
VERSION='3.0'
#==============================================================================

### BEGIN INIT INFO
# Provides:          iptables
# Required-Start:	   $syslog $network
# Required-Stop:	   $syslog $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Configure rules for iptables firewall
# Description:       This script define rules for the iptables firewall
### END INIT INFO

#========== INTERNAL OPTIONS ==========#
PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="Firewall service"
NAME=iptables
SCRIPTNAME=/etc/init.d/$NAME

IPTABLES=$(which iptables)
IP6TABLES=$(which ip6tables)
#IPTABLES_CONFIG=/etc/default/$NAME
IPTABLES_CONFIG=./config

IPTABLES_BACKUP_FILE=/etc/iptables.backup

# The field separator caracter
F_SEP='|'
# The key => config separator
C_SEP=':'


#========== INTERNAL VARIABLES ==========#
IS_DEBUG=0
IS_VERBOSE=0

## WORKING REGEX
# Don't touch unless you know what you are doing
# all regex whose begin with E_ prefix are wrote in extended regex language
# REGEX that describe a IFACE name
REG_IFACE='\([a-zA-Z*][a-zA-Z0-9*]\*\)'
E_REG_IFACE='([a-zA-Z*][a-zA-Z0-9*]*)'

# REGEX that describe a network ipv4 address
REG_IPV4='\(\(\([0-9]\|[1-9][0-9]\|1[0-9]\{2\}\|2[0-4][0-9]\|25[0-5]\).\)\{3\}\([0-9]\|[1-9][0-9]\|1[0-9]\{2\}\|2[0-4][0-9]\|25[0-5]\)\(/\([0-9]\|[12][0-9]\|3[0-2]\)\)\?\)'
E_REG_IPV4='((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]).){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(/([0-9]|[12][0-9]|3[0-2]))?)'

# REGEX that describe a port number (between 1 and 65535)
REG_PORT='\([0-9]\{1,4\}\|[1-5][0-9]\{4\}\|6[0-4][0-9]\{3\}\|65[0-4][0-9]\{2\}\|655[0-2][0-9]\|6553[0-5]\)'
E_REG_PORT='([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])'

# REGEX that describe a port range like PORT-PORT (use this for port mtching)
REG_RANGE="\(${REG_PORT}\(-${REG_PORT}\)\?\)"
E_REG_RANGE="(${E_REG_PORT}(-${E_REG_PORT})?)"

# REGEX that describe a layer 4 protocol
REG_PROTO='\(tcp\|udp\)'
E_REG_PROTO='(tcp|udp)'

# REGEX that describe the source addr
REG_SRC='\(s\|src\)'
E_REG_SRC='(s|src)'

# REGEX that describe the destination addr
REG_DST='\(d\|dst\)'
E_REG_DST='(d|dst)'


#========== INTERNAL FUNCTIONS ==========#

# Print a msg to stdout if verbose option is set
# @param[string] : the msg to write in stdout
function _echo() {
  if [ $IS_VERBOSE -eq 1 ]; then
    echo -e "$@"
  fi
}

# Print a msg to stdout if debug verbose is set
# @param[string] : the msg to write in stdout
function _debug() {
  if [ $IS_DEBUG -eq 1 ]; then
    echo -e "debug: $@"
  fi
}

# Check if the script is run by root or not. If not, prompt error and exit
function _isRunAsRoot() {
  if [ "$(id -u)" != "0" ]; then
    log_failure_msg "$DESC: This script must be run as root."
    exit 1
  fi
}


#========== PROGRAM FUNCTIONS ==========#

## PARSING CONFIG
# Retrieve the procotol string from a input string
# @param[string] : the input string
function parseProtocol() {
  expr match "$1" "$REG_PROTO:.*"
}

# Retrieve the source port (range) string from a input string
# @param[string] : the input string
function parsePortSrc() {
  expr match "$1" ".*:$REG_RANGE:.*"
}

# Retrieve the destination port (range) string from a input string
# @param[string] : the input string
function parsePortDst() {
  expr match "$1" ".*:.*:$REG_RANGE"
}

# Retrieve the ipv4 address from a input string
# @param[string] : the input string
function parseAddress() {
  expr match "$1" ".*:$REG_IPV4"
}

# Retrieve the input iface name string from a input string
# @param[string] : the input string
function parseIfaceInput() {
  expr match "$1" "\([a-zA-Z*][a-zA-0-9*]\*\)"
}

# Retrieve the output iface name string from a input string
# @param[string] : the input string
function parseIfaceOutput() {
  expr match "$1" ".*:$REG_IFACE"
}


### ---
### RULES
### ---
# Remove all rules in all chains
function _rules_flush() {
  $IPTABLES --table filter --flush
  $IPTABLES --table nat --flush
}
# Remove all user defined chains (these what are not built in)
function _chains_flush() {
  $IPTABLES --table filter --delete-chain
  $IPTABLES --table nat --delete-chain
}

### ---
### GLOBAL POLICIES
### ---
# Set policy to open, no security
# @param[string] : the policy type in 'accept', 'drop'
function _policy {
  if [ "$1" = 'accept' ]; then
    # FILTER
    $IPTABLES --table filter --policy INPUT ACCEPT
    $IPTABLES --table filter --policy OUTPUT ACCEPT

    if [ $IF_IPV4_FORWARD -eq 1 ]; then
      $IPTABLES -t filter -P FORWARD ACCEPT
    else
      $IPTABLES -t filter -P FORWARD DROP
    fi

    # NAT
    $IPTABLES --table nat --policy PREROUTING ACCEPT
    $IPTABLES --table nat --policy OUTPUT ACCEPT
    $IPTABLES --table nat --policy INPUT ACCEPT
    $IPTABLES --table nat --policy POSTROUTING ACCEPT
  elif [ "$1" = 'drop' ]; then
    # FILTER
    $IPTABLES --table filter --policy INPUT DROP
    $IPTABLES --table filter --policy OUTPUT DROP

    $IPTABLES --table filter --policy FORWARD DROP
  fi
}






# Load global configuration
[ -r $IPTABLES_CONFIG ] && source $IPTABLES_CONFIG

# Load the VERBOSE setting and other rcS variables
#source /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
#source /lib/lsb/init-functions

# Exit if the iptables is not installed
if ! [ -x "$IPTABLES" ]; then
  exit 0
fi

# Exit if the config have not been sourced
if [ -z "$IF_CONFIG_SOURCED" ]; then
  log_failure_msg "$DESC: Local 'config' file not sourced. Check the '$IPTABLES_CONFIG' path."
  exit 1
fi

IS_DEBUG=1
IS_VERBOSE=1

for entry in $FORWARDED; do
  _debug "entry : $entry"
  protocol=
  src_port=
  dst_port=
  src_address=
  dst_address=
  in_iface=
  out_iface=
  for c in ${entry//${F_SEP}/ }; do
    # full port (dst+src) matching
    if [[ "$c" =~ ^${E_REG_PROTO}${C_SEP}${E_REG_RANGE}$ ]]; then
      _debug "  => proto+port : $c"
      protocol=$(parseProtocol "$c")
      dst_port=$(parsePortSrc "$c")
    elif [[ "$c" =~ ^${E_REG_PROTO}${C_SEP}${E_REG_RANGE}${C_SEP}${E_REG_RANGE}$ ]]; then
      _debug "  => proto+port+port : $c"
      protocol=$(parseProtocol "$c")
      src_port=$(parsePortSrc "$c")
      dst_port=$(parsePortDst "$c")
    # src address matching
    elif [[ "$c" =~ ^${E_REG_SRC}${C_SEP}${E_REG_IPV4}$ ]]; then
      _debug "  => src addr : $c"
      src_address=$(parseAddress "$c")
    # dst address matching
    elif [[ "$c" =~ ^${E_REG_DST}${C_SEP}${E_REG_IPV4}$ ]]; then
      _debug "  => dst addr : $c"
      dst_address=$(parseAddress "$c")
    # iface reading matching
    elif [[ "$c" =~ ^${E_REG_IFACE}${C_SEP}${E_REG_IFACE}$ ]]; then
      _debug "  => iface+iface : $c"
      echo $(parseIfaceInput "$c")
      in_iface=$(parseIfaceInput "$c")
      out_iface=$(parseIfaceOutput "$c")
    else
      _debug "  # error : $c"
    fi
  done
  _echo $IPTABLES --table filter -i $in_iface -o $out_iface -s $src_address -d $dst_address -p $protocol -sport $src_port -dport $dst_port  
  
done

exit 0

###############################
###############################
# DO NOT READ UNDER THIS LINE #
###############################
###############################












###########################
# Start the Firewall rules
###########################
# Start function, it setup all firewall rules according to configuration
# @return[int] : 0 if rules have been correctly set
#          2 if rules could not be set
function do_start() {
  _flush_all_rules
  _flush_all_chains
  _set_close_policy
  #_set_packet_rules
  if [ $? -ne 0 ]; then
  	return 2
  fi

  _allow_connection_state
  _allow_input_output_icmp

  if [ -n "$NETWORK_LOOPBACK" ]; then
  	_allow_loopback_interface
  fi

  _allow_input_output_service_for_all

  if [ -n "$NETWORK_ETH0" ]; then
  	_allow_input_output_service_for_eth0
  fi
  if [ -n "$NETWORK_WLAN0" ]; then
  	_allow_input_output_service_for_wlan0
  fi
  if [ -n "$NETWORK_VPN" ]; then
  	_allow_input_output_service_for_vpn
  fi
  if [ -n "$NETWORK_ETH0_ALT" ]; then
  	_allow_input_output_service_for_eth0_0
  fi

  if [ "$IF_IPV4_FORWARD" -eq 1 ]; then
  	_allow_routing_icmp
  	_allow_routing_service
  	_setup_nat_masquerading
  fi
}

##########################
# Stop the Firewall rules
##########################

# Remove all rules of the firewall, turn it open policy
# return[int] : 0 if rules have been correctly remove
#               2 if rules could not be remove
function do_stop() {
  _set_open_policy
  if [ $? -ne 0 ]; then
  	return 2
  fi

  _flush_all_rules
  _flush_all_chains
}

##########################
# Restart the Firewall rules
##########################

# Restart all rules of the firewall
# return :	0 if rules have been correctly remove
#			2 if firewall failed to start
#			3 if firewall failed to stop
function do_restart() {
  _do_stop 2>/dev/null
  case $? in
  0|1)
  # stop success, now run start
  	_do_start 2>/dev/null
  	case $? in
  	# Start sucess
  	0|1)	return 0;;
  	# Failed to start
  	*)	return 2;;
  	esac
  	;;
  # Failed to stop
  *)	return 3;;
  esac
}

##########################
# Test the Firewall rules
##########################

# Save all firewall rules in a file
# param[in] : OPTIONNAL the path of the file to write the firewall rules
# return :	0 if rules have been correctly saved
#			2 if save failed
function do_save() {
  local dest_file="$1"
  if [ -z "$1" ]; then
  	dest_file=${IPTABLES_BACKUP_FILE}
  fi
  hash iptables-save 2>/dev/null 1>&2
  if [ $? -ne 0 ]; then
  	return 2
  fi

  /sbin/iptables-save > ${dest_file}
}

# Restore all firewall rules from a file
# return :	0 if rules have been correctly restored
#			2 if restore failed
function do_restore() {
  hash iptables-restore 2>/dev/null 1>&2
  if [ $? -ne 0 ]; then
  	return 2
  fi

  if [ -f "${IPTABLES_BACKUP_FILE}" ]; then
  	/sbin/iptables-restore < ${IPTABLES_BACKUP_FILE}
  fi
}

# Apply new firewall rules and wait for an user confirmation before saving them
# return :	0 if rules have been correctly set
#			2 if applying failed
function do_test() {
  log_action_msg 'Saving current firewall rules'
  _do_save
  if [ $? -ne 0 ]; then
  	log_failure_msg 'Unable to save current rules'
  	return 2
  fi

  log_warning_msg 'Be careful that the caracters are put to screen after you typed them to ensure a bi-directionnal communication'
  log_warning_msg "Previous configuration will be restore in ${TIMEOUT_FOR_TEST} seconds if no action is performed. Type 'OK' apply new rules [wait for ${TIMEOUT_FOR_TEST}s]"
  log_action_msg 'Testing and applying new rules'
  _do_restart

  read -t "${TIMEOUT_FOR_TEST}" -n 2 input
  echo "$input" | grep --ignore-case 'ok' >/dev/null 2>&1
  if [ $? -eq 0 ]; then
  	log_success_msg 'Saving new rules'
  else
  	local debug_file="/tmp/iptables_$(date +%Y-%m-%d_%H-%M)"
  	_do_save "$debug_file"
  	log_warning_msg "A snapshot of the new firewall rules have been save to $debug_file"
  	_do_restore
  	if [ $? -ne 0 ]; then
  		log_failure_msg 'Unable to restore current rules'
  		return 2
  	fi
  	log_failure_msg 'Old rules have been restored'
  	return 2
  fi
}




#========== MAIN FUNCTION ==========#
# Main
# param	:same of the script
# return	:
function main() {
  _check_runas_root

  ### ARGUMENTS PARSING
  case "$1" in
  start)
    log_daemon_msg "Setting firewall rules. Enable firewall secure policy" "$NAME"
    do_start 2> /dev/null
    case $? in
    0|1) log_end_msg 0;;
    *) log_end_msg 1
      log_failure_msg "$DESC: Failed to start the firewall."
      ;;
    esac
    ;;
  stop)
    log_daemon_msg "Removing firewall rules. Turn firewall to open policy" "$NAME"
    do_stop 2>/dev/null
    case $? in
    0|1)	log_end_msg 0;;
    *) log_end_msg 1
      log_failure_msg "$DESC: Failed to stop the firewall."
      ;;
    esac
    ;;
  restart)
    log_daemon_msg "Re-setting firewall rules" "$NAME"
    do_restart 2>/dev/null
    case $? in
    # restart success
    0|1)	log_end_msg 0;;
    # start failed
    2)	log_end_msg 1
      log_failure_msg "$DESC: Failed to start the firewall."
      ;;
    # stop failed
    3)	log_end_msg 1
      log_failure_msg "$DESC: Failed to stop the firewall."
      ;;
    esac
    ;;
  restore)
    log_daemon_msg "Loading firewall rules from ${IPTABLES_BACKUP_FILE}" "$NAME"
    do_restore 2>/dev/null
    case "$?" in
    0|1) log_end_msg 0 ;;
    *) log_end_msg 1 ;;
    esac
    ;;
  test)
    log_action_msg "Testing new firewall rulesets" "$NAME"
    do_test 2>/dev/null
    ;;
  *)
    echo "Usage: $SCRIPTNAME {start|stop|restart|save|restore|test}" >&2
    exit 3
    ;;
  esac
}

main "$@"





































### ---
### PACKETS
### ---
# Set specific rules which concerns packet
function _set_packet_rules() {
  # Drop broadcast paquets
  $IPTABLES -A INPUT -m pkttype --pkt-type broadcast -j DROP
}



### ---
### INTERFACE
### ---
function _allow_loopback_interface() {
# Allow loopback interface
  $IPTABLES -t filter -A INPUT -i lo --source ${NETWORK_LOOPBACK} --destination ${NETWORK_LOOPBACK} -j ACCEPT
  $IPTABLES -t filter -A OUTPUT -o lo --source ${NETWORK_LOOPBACK} --destination ${NETWORK_LOOPBACK} -j ACCEPT
}



### ---
### CONNECTION STATE
### ---
function _allow_connection_state() {
# Keep established connections
  if [ -n "$NETWORK_ETH0" ]; then
    $IPTABLES -A INPUT -i eth0 --destination ${NETWORK_ETH0} -m state --state RELATED,ESTABLISHED -j ACCEPT
    $IPTABLES -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -m state --state RELATED,ESTABLISHED -j ACCEPT
  fi

  if [ -n "$NETWORK_WLAN0" ]; then
    $IPTABLES -A INPUT -i wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -m state --state RELATED,ESTABLISHED -j ACCEPT
    $IPTABLES -A OUTPUT -o wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -m state --state RELATED,ESTABLISHED -j ACCEPT
  fi

  if [ -n "$NETWORK_VPN" ]; then
    $IPTABLES -A INPUT -i tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -m state --state RELATED,ESTABLISHED -j ACCEPT
    $IPTABLES -A OUTPUT -o tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -m state --state RELATED,ESTABLISHED -j ACCEPT
  fi

  if [ -n "$NETWORK_ETH0_ALT" ]; then
    $IPTABLES -A INPUT -i eth0 --source ${NETWORK_ETH0_ALT} --destination ${HOST_LOCAL_ALT} -m state --state RELATED,ESTABLISHED -j ACCEPT
    $IPTABLES -A OUTPUT -o eth0 --source ${HOST_LOCAL_ALT} --destination ${NETWORK_ETH0_ALT} -m state --state RELATED,ESTABLISHED -j ACCEPT
  fi

  if [ $IF_IPV4_FORWARD -eq 1 ]; then
    $IPTABLES -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
  fi
}

function _setup_nat_masquerading() {
  if [ -n "$NETWORK_VPN" ]; then
    $IPTABLES -t nat -A POSTROUTING -o eth0 --source ${NETWORK_VPN} -j MASQUERADE -m comment --comment "Masquerade connection from VPN network to eth0"
  fi
}


### ---
### PROTOCOLE ICMP
### ---
# Set the rules for allow icmp input output
function _allow_input_output_icmp() {
# ICMP [In,Out]
if [ -n "$NETWORK_ETH0" ]; then
  $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p icmp -j ACCEPT -m comment --comment "Allow PING in for eth0 network"
  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p icmp -j ACCEPT -m comment --comment "Allow PING out from eth0"
fi

if [ -n "$NETWORK_WLAN0" ]; then
  $IPTABLES -t filter -A INPUT -i wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -p icmp -j ACCEPT -m comment --comment "Allow PING in for wlan0 network"
  $IPTABLES -t filter -A OUTPUT -o wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -p icmp -j ACCEPT -m comment --comment "Allow PING out from wlan0"
fi

if [ -n "$NETWORK_VPN" ]; then
  $IPTABLES -t filter -A INPUT -i tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -p icmp -j ACCEPT -m comment --comment "Allow PING in for vpn network"
  $IPTABLES -t filter -A OUTPUT -o tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -p icmp -j ACCEPT -m comment --comment "Allow PING out from vpn network"
fi
}

# Set the rules for icmp packets routing
function _allow_routing_icmp() {
# ICMP [Forward]
  $IPTABLES -t filter -A FORWARD -p icmp -j ACCEPT -m comment --comment "Allow ICMP routing"
}





### ---
### SERVICES
### ---
# Set the rules for input or output connections



## ALL
function _allow_input_output_service_for_all() {
# WakeOnLan AND Wol Relayd[In,Out]
  if [ -n "${WOLRELAYD_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -p udp --dport ${WOLRELAYD_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow Wake On Lan relay in"
    $IPTABLES -t filter -A OUTPUT -p udp --dport ${WOLRELAYD_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow Wake On Lan out"
  fi

# DHCP server [In,Out]
  $IPTABLES -t filter -A INPUT -p udp --sport 68 --dport 67 -j ACCEPT -m comment --comment "Allow DHCP server in from all"
  $IPTABLES -t filter -A OUTPUT -p udp --sport 67 --dport 68 -j ACCEPT -m comment --comment "Allow DHCP server out from all"
}



## %%%%%%%%%%%%%%%%%  ETH0  %%%%%%%%%%%%%%%%%
function _allow_input_output_service_for_eth0() {

# SSH [In,Out]
  if [ -n "${SSHD_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p tcp --dport ${SSHD_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow SSH in for eth0"
    $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 22 -j ACCEPT -m comment --comment "Allow SSH out from eth0"
  fi

# WHOIS []
  #$IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 43 -j ACCEPT -m comment --comment "Allow WHOIS lookup from eth0"

# SMTP [In]
  $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p tcp --dport 25 -j ACCEPT -m comment --comment "Allow SMTP in for eth0"

# DNS [In,Out]
  if [ -n "${BIND_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p udp --dport ${BIND_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow DNS in for eth0"
    $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p tcp --dport ${BIND_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow DNS in for eth0"
  fi

  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p udp --dport 53 -j ACCEPT -m comment --comment "Allow DNS out from eth0"
  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 53 -j ACCEPT -m comment --comment "Allow DNS out from eth0"

# DHCP client []
  #$IPTABLES -t filter -A OUTPUT -p udp --sport 68 --dport 67 -j ACCEPT -m comment --comment "Allow DHCP client out from all"

# HTTP [Out]
#	$IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p tcp --dport 80 -j ACCEPT -m comment --comment "Allow HTTP in for eth0"
  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 80 -j ACCEPT -m comment --comment "Allow HTTP out from eth0"

# NTP [Out]
  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p udp --dport 123 -j ACCEPT -m comment --comment "Allow NTP out from eth0"

# Https [Out]
  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 443 -j ACCEPT -m comment --comment "Allow HTTPs out from eth0"

# Microsoft-ds/Cifs [Out]
  if [ -n "${CIFS_PORT}" ]; then
    $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p tcp --dport ${CIFS_PORT} -j ACCEPT -m comment --comment "Allow Microsoft-ds/CIFS out from eth0 for lan"
  fi

# Smtps []
  #$IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 465 -j ACCEPT -m comment --comment "Allow SMTPs out from eth0"

# Syslog [In]
  if [ -n "${SYSLOG_REMOTE_HOSTS}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --source "${SYSLOG_REMOTE_HOST}" --destination ${NETWORK_ETH0} -p udp --dport 514 -j ACCEPT -m comment --comment "Allow Remote Syslog entries in for eth0"
    $IPTABLES -t filter -A INPUT -i eth0 --source "${SYSLOG_REMOTE_HOST}" --destination ${NETWORK_ETH0} -p tcp --dport 514 -j ACCEPT -m comment --comment "Allow Remote Syslog entries in for eth0"
  fi

# Submission [Out]
  if [ -n "${POSTFIX_RELAYHOST_ADDRESS}" ]; then
    $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} --destination ${POSTFIX_RELAYHOST_ADDRESS} -p tcp --dport 587 -j ACCEPT -m comment --comment "Allow Authentified SMTP (Submission) out from eth0"
  fi

# OpenVPN [In]
  if [ -n "${OPENVPN_LISTEN_PORT}" ] && [ -n "${OPENVPN_LISTEN_PROTOCOL}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p ${OPENVPN_LISTEN_PROTOCOL} --dport ${OPENVPN_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow VPN in for eth0"
  fi

# Minissdpd []
  #$IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p udp --dport 1900 -j ACCEPT -m comment --comment "Allow SSDP in for eth0"

# Mysql [In]
  if [ -n "${MYSQL_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p tcp --dport ${MYSQL_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow MySQL in for eth0"
  fi

# ShellInABox [In]
  if [ -n "${SHELLINABOX_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p tcp --dport ${SHELLINABOX_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow WebSSH ShellInABox in for eth0"
  fi

# NAT-PMP []
  #$IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p udp --dport 5351 -j ACCEPT -m comment --comment "Allow NAT-PMP out from eth0"

# Transmission torrent control panel [In]
  if [ -n "${TRANSMISSION_RPC_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0} --destination ${NETWORK_ETH0} -p tcp --dport ${TRANSMISSION_RPC_LISTEN_PORT} -j ACCEPT  -m comment --comment "Allow Transmission Remote Web Panel in for eth0"
  fi

# Git [Out]
  $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp --dport 9418 -j ACCEPT -m comment --comment "Allow Git out from eth0"

# Transmission torrent peer [In,Out]
  if [ -n "${TRANSMISSION_PEER_LISTEN_PORT}" ] && [ -n "${TRANSMISSION_USERNAME}" ]; then
    $IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p udp --dport ${TRANSMISSION_PEER_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow Transmission Torrent peer listen for eth0"
    $IPTABLES -t filter -A INPUT -i eth0 --destination ${NETWORK_ETH0} -p tcp --dport ${TRANSMISSION_PEER_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow Transmission Torrent peer listen for eth0"

    $IPTABLES -t filter -A OUTPUT -o eth0 --source ${NETWORK_ETH0} -p tcp -m owner --uid-owner ${TRANSMISSION_USERNAME} -j ACCEPT -m comment --comment "Allow Transmission Torrent data upload for SYSTEM USER ${TRANSMISSION_USERNAME}"
  fi
}



## %%%%%%%%%%%%%%%%%  WLAN0  %%%%%%%%%%%%%%%%%
function _allow_input_output_service_for_wlan0() {

# SSH [In]
  if [ -n "${SSHD_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -p tcp --dport ${SSHD_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow SSH in for wlan0"
  fi

# DNS [In]
  if [ -n "${BIND_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -p udp --dport ${BIND_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow DNS in for wlan0"
    $IPTABLES -t filter -A INPUT -i wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -p tcp --dport ${BIND_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow DNS in for wlan0"
  fi

# HTTP [In]
#	$IPTABLES -t filter -A INPUT -i wlan0 --destination ${NETWORK_WLAN0} -p tcp --dport 80 -j ACCEPT -m comment --comment "Allow HTTP in for wlan0"

# Transmission torrent control panel [In]
  if [ -n "${TRANSMISSION_RPC_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i wlan0 --source ${NETWORK_WLAN0} --destination ${NETWORK_WLAN0} -p tcp --dport ${TRANSMISSION_RPC_LISTEN_PORT} -j ACCEPT  -m comment --comment "Allow Transmission Remote Web Panel in for wlan0"
  fi
}



## %%%%%%%%%%%%%%%%%  TUN0 (vpn)  %%%%%%%%%%%%%%%%%
function _allow_input_output_service_for_vpn() {

# SSH [In]
if [ -n "${SSHD_LISTEN_PORT}" ]; then
  $IPTABLES -t filter -A INPUT -i tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -p tcp --dport ${SSHD_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow SSH in for VPN"
fi

# DNS [In]
  if [ -n "${BIND_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -p udp --dport ${BIND_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow DNS in for VPN"
    $IPTABLES -t filter -A INPUT -i tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -p tcp --dport ${BIND_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow DNS in for VPN"
  fi

# HTTP [In]
#	$IPTABLES -t filter -A INPUT -i tun0 --destination ${NETWORK_VPN} -p tcp --dport 80 -j ACCEPT -m comment --comment "Allow HTTP in for VPN"

# Transmission torrent control panel [In]
  if [ -n "${TRANSMISSION_RPC_LISTEN_PORT}" ]; then
    $IPTABLES -t filter -A INPUT -i tun0 --source ${NETWORK_VPN} --destination ${NETWORK_VPN} -p tcp --dport ${TRANSMISSION_RPC_LISTEN_PORT} -j ACCEPT  -m comment --comment "Allow Transmission Remote Web Panel in for VPN"
  fi
}



## %%%%%%%%%%%%%%%%% ETH0:0  %%%%%%%%%%%%%%%%%
function _allow_input_output_service_for_eth0_0() {

# SSH [In]
if [ -n "${SSHD_LISTEN_PORT}" ]; then
  $IPTABLES -t filter -A INPUT -i eth0 --source ${NETWORK_ETH0_ALT} --destination ${HOST_LOCAL_ALT} -p tcp --dport ${SSHD_LISTEN_PORT} -j ACCEPT -m comment --comment "Allow SSH in for eth0-ALT"
fi
}





# Set rule for service packets routing
function _allow_routing_service() {
  # ignore empty and commented lines
  local forwardedPort=$(echo "$FORWARDED_PORT" | grep --invert-match --regexp='#' --regexp='^$')
  # count the number of rules
  local nbLine=$(echo "$forwardedPort" | wc -l)

  for i in `seq $nbLine`; do
    line=$(echo "$forwardedPort" | head -n $i | tail -n1)

    # get comment informations
    if [ -n "$(echo $line | grep 'comment/')" ]; then
      local comment_opts=$(echo $line | sed -E 's/^.*(comment)\/("[-_A-Za-z ]+").*/-m comment --comment/')
      local comment_text=$(echo $line | sed -E 's/^.*comment\/"([-_A-Za-z ]+)".*/\1/')
    fi

    local port_opts=$(echo $line | sed -E 's/^(tcp|udp)\/([0-9:]+).*/-p \1 --dport \2/')
    # apply rule
    $IPTABLES -t filter -A FORWARD $port_opts -j ACCEPT $comment_opts "$comment_text"
  done
}




####### GARBAGE

# HTTP + HTTPS Out
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 80 -j ACCEPT
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 443 -j ACCEPT

# HTTP + HTTPS In
#$IPTABLES -t filter -A INPUT -p tcp --dport 80 -j ACCEPT
#$IPTABLES -t filter -A INPUT -p tcp --dport 443 -j ACCEPT
#$IPTABLES -t filter -A INPUT -p tcp --dport 8443 -j ACCEPT

# FTP Out
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 20:21 -j ACCEPT

# FTP In
#modprobe ip_conntrack_ftp # ligne facultative avec les serveurs OVH
#$IPTABLES -t filter -A INPUT -p tcp --dport 20:21 -j ACCEPT
#$IPTABLES -t filter -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Mail SMTP:25
#$IPTABLES -t filter -A INPUT -p tcp --dport 25 -j ACCEPT
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 25 -j ACCEPT

# Mail POP3:110
#$IPTABLES -t filter -A INPUT -p tcp --dport 110 -j ACCEPT
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 110 -j ACCEPT

# Mail IMAP:143
#$IPTABLES -t filter -A INPUT -p tcp --dport 143 -j ACCEPT
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 143 -j ACCEPT

# Mail POP3S:995
#$IPTABLES -t filter -A INPUT -p tcp --dport 995 -j ACCEPT
#$IPTABLES -t filter -A OUTPUT -p tcp --dport 995 -j ACCEPT
