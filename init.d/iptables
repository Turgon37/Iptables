#!/bin/bash

### BEGIN INIT INFO
# Provides:          iptables
# Required-Start:	   $syslog $network
# Required-Stop:	   $syslog $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Configure rules for iptables firewall
# Description:       This script define rules for the iptables firewall
### END INIT INFO

# Author Pierre GINDRAUD <pgindraud@gmail.com>

PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="Firewall service"
NAME=iptables
SCRIPTNAME=/etc/init.d/$NAME

# Load the VERBOSE setting and other rcS variables
source /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
source /lib/lsb/init-functions

# Exit if the iptables is not installed
[ -x "$IPTABLES" ] || exit 0

# Exit if the config have not been sourced
if [ -z "$IF_CONFIG_SOURCED" ]; then
  log_failure_msg "$DESC: Local 'config' file not sourced. Check the '$IPTABLES_CONFIG' path."
  exit 1
fi







###########################
# Start the Firewall rules
###########################
# Start function, it setup all firewall rules according to configuration
# @return[int] : 0 if rules have been correctly set
#          2 if rules could not be set
function do_start() {
  _flush_all_rules
  _flush_all_chains
  _set_close_policy
  #_set_packet_rules
  if [ $? -ne 0 ]; then
  	return 2
  fi

  _allow_connection_state
  _allow_input_output_icmp

  if [ -n "$NETWORK_LOOPBACK" ]; then
  	_allow_loopback_interface
  fi

  _allow_input_output_service_for_all

  if [ -n "$NETWORK_ETH0" ]; then
  	_allow_input_output_service_for_eth0
  fi
  if [ -n "$NETWORK_WLAN0" ]; then
  	_allow_input_output_service_for_wlan0
  fi
  if [ -n "$NETWORK_VPN" ]; then
  	_allow_input_output_service_for_vpn
  fi
  if [ -n "$NETWORK_ETH0_ALT" ]; then
  	_allow_input_output_service_for_eth0_0
  fi

  if [ "$IF_IPV4_FORWARD" -eq 1 ]; then
  	_allow_routing_icmp
  	_allow_routing_service
  	_setup_nat_masquerading
  fi
}

##########################
# Stop the Firewall rules
##########################

# Remove all rules of the firewall, turn it open policy
# return[int] : 0 if rules have been correctly remove
#               2 if rules could not be remove
function do_stop() {
  _set_open_policy
  if [ $? -ne 0 ]; then
  	return 2
  fi

  _flush_all_rules
  _flush_all_chains
}

##########################
# Restart the Firewall rules
##########################

# Restart all rules of the firewall
# return :	0 if rules have been correctly remove
#			2 if firewall failed to start
#			3 if firewall failed to stop
function do_restart() {
  _do_stop 2>/dev/null
  case $? in
  0|1)
  # stop success, now run start
  	_do_start 2>/dev/null
  	case $? in
  	# Start sucess
  	0|1)	return 0;;
  	# Failed to start
  	*)	return 2;;
  	esac
  	;;
  # Failed to stop
  *)	return 3;;
  esac
}

##########################
# Test the Firewall rules
##########################

# Save all firewall rules in a file
# param[in] : OPTIONNAL the path of the file to write the firewall rules
# return :	0 if rules have been correctly saved
#			2 if save failed
function do_save() {
  local dest_file="$1"
  if [ -z "$1" ]; then
  	dest_file=${IPTABLES_BACKUP_FILE}
  fi
  hash iptables-save 2>/dev/null 1>&2
  if [ $? -ne 0 ]; then
  	return 2
  fi

  /sbin/iptables-save > ${dest_file}
}

# Restore all firewall rules from a file
# return :	0 if rules have been correctly restored
#			2 if restore failed
function do_restore() {
  hash iptables-restore 2>/dev/null 1>&2
  if [ $? -ne 0 ]; then
  	return 2
  fi

  if [ -f "${IPTABLES_BACKUP_FILE}" ]; then
  	/sbin/iptables-restore < ${IPTABLES_BACKUP_FILE}
  fi
}

# Apply new firewall rules and wait for an user confirmation before saving them
# return :	0 if rules have been correctly set
#			2 if applying failed
function do_test() {
  log_action_msg 'Saving current firewall rules'
  _do_save
  if [ $? -ne 0 ]; then
  	log_failure_msg 'Unable to save current rules'
  	return 2
  fi

  log_warning_msg 'Be careful that the caracters are put to screen after you typed them to ensure a bi-directionnal communication'
  log_warning_msg "Previous configuration will be restore in ${TIMEOUT_FOR_TEST} seconds if no action is performed. Type 'OK' apply new rules [wait for ${TIMEOUT_FOR_TEST}s]"
  log_action_msg 'Testing and applying new rules'
  _do_restart

  read -t "${TIMEOUT_FOR_TEST}" -n 2 input
  echo "$input" | grep --ignore-case 'ok' >/dev/null 2>&1
  if [ $? -eq 0 ]; then
  	log_success_msg 'Saving new rules'
  else
  	local debug_file="/tmp/iptables_$(date +%Y-%m-%d_%H-%M)"
  	_do_save "$debug_file"
  	log_warning_msg "A snapshot of the new firewall rules have been save to $debug_file"
  	_do_restore
  	if [ $? -ne 0 ]; then
  		log_failure_msg 'Unable to restore current rules'
  		return 2
  	fi
  	log_failure_msg 'Old rules have been restored'
  	return 2
  fi
}




#========== MAIN FUNCTION ==========#
# Main
# param	:same of the script
# return	:
function main() {
  _check_runas_root

  ### ARGUMENTS PARSING
  case "$1" in
  start)
    log_daemon_msg "Setting firewall rules. Enable firewall secure policy" "$NAME"
    do_start 2> /dev/null
    case $? in
    0|1) log_end_msg 0;;
    *) log_end_msg 1
      log_failure_msg "$DESC: Failed to start the firewall."
      ;;
    esac
    ;;
  stop)
    log_daemon_msg "Removing firewall rules. Turn firewall to open policy" "$NAME"
    do_stop 2>/dev/null
    case $? in
    0|1)	log_end_msg 0;;
    *) log_end_msg 1
      log_failure_msg "$DESC: Failed to stop the firewall."
      ;;
    esac
    ;;
  restart)
    log_daemon_msg "Re-setting firewall rules" "$NAME"
    do_restart 2>/dev/null
    case $? in
    # restart success
    0|1)	log_end_msg 0;;
    # start failed
    2)	log_end_msg 1
      log_failure_msg "$DESC: Failed to start the firewall."
      ;;
    # stop failed
    3)	log_end_msg 1
      log_failure_msg "$DESC: Failed to stop the firewall."
      ;;
    esac
    ;;
  restore)
    log_daemon_msg "Loading firewall rules from ${IPTABLES_BACKUP_FILE}" "$NAME"
    do_restore 2>/dev/null
    case "$?" in
    0|1) log_end_msg 0 ;;
    *) log_end_msg 1 ;;
    esac
    ;;
  test)
    log_action_msg "Testing new firewall rulesets" "$NAME"
    do_test 2>/dev/null
    ;;
  *)
    echo "Usage: $SCRIPTNAME {start|stop|restart|save|restore|test}" >&2
    exit 3
    ;;
  esac
}

main "$@"